#!/usr/bin/env bash
# creates a vanilla dump to the given output file path
# this script uses the docker-entrypoint script from the postgres image
# the following is done:
# - starts a postgres server in single-user mode
# - runs the "$SCHEMA_DIR/sql/init.sql" script against that server
# - dumps the schema using pg_dump to the file given as arguments
set -e

export PGDATA="/tmp/vanilla_pgdata"
export PGHOST=''
export POSTGRES_HOST_AUTH_METHOD=trust

trap '{ echo "cleaning up $PGDATA" && rm -rf -- "$PGDATA"; }' EXIT

source /usr/local/bin/docker-entrypoint.sh
docker_setup_env
# setup data directories and permissions (when run as root)
docker_create_db_directories

if [ "$(id -u)" = '0' ]; then
  # ensure no to delete stale pgdata
  rm -rf $PGDATA
  # then restart script as postgres user
  exec gosu postgres "$BASH_SOURCE" "$@"
fi

init_script="$SCHEMA_DIR/sql/init.sql"
dump_file="$1"
shift

echo "using init_script=$init_script and dumpfile=$dump_file"


# only run initialization on an empty data directory
if [ -z "$DATABASE_ALREADY_EXISTS" ]; then
  docker_verify_minimum_env

  docker_init_database_dir
  pg_setup_hba_conf

  # PGPASSWORD is required for psql when authentication is required for 'local' connections via pg_hba.conf and is otherwise harmless
  # e.g. when '--auth=md5' or '--auth-local=md5' is used in POSTGRES_INITDB_ARGS
  export PGPASSWORD="${PGPASSWORD:-$POSTGRES_PASSWORD}"
  docker_temp_server_start

  docker_setup_db

  # make sure the script runs in its directory
  cd "$SCHEMA_DIR/sql"
  echo "running init script $init_script"
  docker_process_init_files "$init_script"

  pg_dump $DIFFDB_DUMP_OPTIONS -f $dump_file

  docker_temp_server_stop
  unset PGPASSWORD
else
  echo
  echo 'PostgreSQL Database directory appears to contain a database; Skipping initialization'
  echo
  exit 1
fi
